<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VybeScore Dashboard</title>
  <link rel="stylesheet" href="vybestack.css" />
</head>
<body>
  <main class="container">
    <header class="top-bar">
      <div>
        <h1>VybeScore Dashboard</h1>
        <p class="cta-lead">Daily Model Performance</p>
      </div>
    </header>

    <section>
      <h2>Daily Overview</h2>
      <div class="table-wrapper">
        <table id="daily-table">
          <thead>
            <tr>
              <th class="sortable" data-field="profileLabel">Profile</th>
              <th class="sortable sorted desc numeric" data-field="totalVybes">Total Vybes</th>
              <th class="sortable numeric" data-field="runs">Runs</th>
              <th class="sortable numeric" data-field="avgVybes">Avg Vybes</th>
              <th class="sortable numeric" data-field="avgSuccess">Avg Success</th>
              <th class="sortable numeric" data-field="avgPenalty">Avg Penalty</th>
              <th>Best Run</th>
              <th>Worst Run</th>
            </tr>
          </thead>
          <tbody id="daily-summary"></tbody>
        </table>
      </div>
    </section>

    <section>
      <h2>Daily Run Summary</h2>
      <div class="table-wrapper">
        <table id="day-table">
          <thead>
            <tr>
              <th class="sortable sorted desc" data-field="sortValue">Date</th>
              <th class="sortable numeric" data-field="totalRuns">Runs</th>
              <th class="sortable numeric" data-field="totalMinutes">Minutes</th>
              <th class="sortable numeric" data-field="avgVybes">Avg Vybes</th>
              <th class="sortable" data-field="profilesLabel">Profiles</th>
              <th class="sortable" data-field="versionsLabel">Repo Versions</th>
            </tr>
          </thead>
          <tbody id="daily-run-summary"></tbody>
        </table>
      </div>
    </section>

    <section>
      <h2>Run Log</h2>
      <div id="run-log" class="run-log"></div>
    </section>

    <footer>
      Updated <span id="updated-at">never</span>.
    </footer>
  </main>

  <script type="module">
    const PROFILE_LABELS = {
      'llxprt-synthetic-main': 'Synthetic GLM 4.6',
      'llxprt-cerebras-main': 'Cerebras Qwen 3',
      'llxprt-synthetic-glm4.6-temp1': 'Synthetic GLM 4.6 (legacy)',
      'cerebrasqwen3-qwen3-coder-temp1': 'Cerebras Qwen 3 (legacy)',
      'codex-exec-gpt5-default': 'Codex GPT-5 (legacy)'
    };

    const EVAL_LABELS = {
      'base64-fix': 'Base64 Toolkit Fix',
      'form-capture': 'Friendly Form Capture',
      'pagination': 'Pagination Service Repair',
      'react-evaluation': 'Reactive Programming Primitives',
      'regex-challenge': 'Regex Challenge Toolkit',
      'report-builder': 'Report Builder Repair'
    };

    const formatter = new Intl.NumberFormat(undefined, { maximumFractionDigits: 2 });
    const percentFormatter = new Intl.NumberFormat(undefined, { style: 'percent', maximumFractionDigits: 1 });
    const dateFormatter = new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'short' });
    const dayFormatter = new Intl.DateTimeFormat(undefined, { dateStyle: 'long' });

    const dailyBody = document.getElementById('daily-summary');
    const daySummaryBody = document.getElementById('daily-run-summary');
    const runLogContainer = document.getElementById('run-log');
    const dailyTable = document.getElementById('daily-table');
    const daySummaryTable = document.getElementById('day-table');
    const updatedAtEl = document.getElementById('updated-at');

    const dailyEntriesByDate = new Map();
    const configOrder = [];
    const configSet = new Set();
    let orderedConfigs = [];
    let latestDayKey = null;
    let activeDayKey = null;
    let currentDailyRows = [];
    let currentDaySummaryRows = [];
    let currentRunRows = [];
    let currentRunGroups = [];
    const dailySort = { field: 'totalVybes', desc: true };
    const daySort = { field: 'sortValue', desc: true };

    async function safeFetch(path) {
      const response = await fetch(path);
      if (!response.ok) {
        throw new Error(`Failed to load ${path}: ${response.status}`);
      }
      return response.json();
    }

    function buildDailyRowMarkup(row) {
      const best = row.bestRun
        ? `${EVAL_LABELS[row.bestRun.eval] ?? row.bestRun.eval} (${formatter.format(row.bestRun.score)})`
        : '–';
      const worst =
        row.worstRun && row.worstRun.runId !== row.bestRun?.runId
          ? `${EVAL_LABELS[row.worstRun.eval] ?? row.worstRun.eval} (${formatter.format(row.worstRun.score)})`
          : '–';
      return `<tr>
        <td>
          <div class="cell-heading">
            <span>${row.profileLabel}</span>
            <div class="version-tag-group">${formatVersionTags(row.repoVersions)}</div>
          </div>
          <small>${row.date}</small>
        </td>
        <td class="numeric" data-field="totalVybes">${formatter.format(row.totalVybes)}</td>
        <td class="numeric" data-field="runs">${row.runs}</td>
        <td class="numeric" data-field="avgVybes">${formatter.format(row.avgVybes)}</td>
        <td class="numeric" data-field="avgSuccess">${percentFormatter.format(row.avgSuccess)}</td>
        <td class="numeric" data-field="avgPenalty">${formatter.format(row.avgPenalty)}</td>
        <td>${best}</td>
        <td>${worst}</td>
      </tr>`;
    }

    function createDailyRows(entries = []) {
      const rows = [];
      entries.forEach((entry) => {
        if (!entry) return;
        const dayLabel = entry.date === 'unknown' ? 'Unknown Date' : entry.date;
        const profiles = Object.entries(entry.profiles);
        profiles.forEach(([configId, stats]) => {
          rows.push({
            date: dayLabel,
            configId,
            totalVybes: stats.totalVybes,
            runs: stats.runs,
            avgVybes: stats.avgVybes,
            avgSuccess: stats.avgSuccess,
            avgPenalty: stats.avgPenalty,
            bestRun: stats.bestRun,
            worstRun: stats.worstRun,
            profileLabel: PROFILE_LABELS[configId] ?? configId,
            repoVersions: stats.repoVersions ?? []
          });
        });
      });
      return rows;
    }

    function createDaySummaryRows(daily) {
      return daily.map((entry) => {
        const summary = entry.summary ?? {};
        const rawDate = entry.date ?? 'unknown';
        const profiles = (summary.profiles ?? []).map((configId) => PROFILE_LABELS[configId] ?? configId);
        const versions = summary.repoVersions ?? [];
        const label =
          rawDate === 'unknown' ? 'Unknown Date' : dayFormatter.format(new Date(`${rawDate}T00:00:00Z`));
        return {
          rawDate,
          dateLabel: label,
          totalRuns: summary.totalRuns ?? 0,
          totalMinutes: summary.totalMinutes ?? 0,
          avgVybes: summary.avgVybes ?? 0,
          profilesLabel: profiles.join(', ') || '–',
          repoVersions: versions,
          versionsLabel: versions.join(', ') || 'unknown',
          sortValue: rawDate !== 'unknown' ? Date.parse(`${rawDate}T00:00:00Z`) : 0
        };
      });
    }

    function formatVersionTags(versions) {
      if (!versions || versions.length === 0) {
        return '<span class="version-pill muted">unknown</span>';
      }
      return versions.map((version) => `<span class="version-pill">${version}</span>`).join('');
    }

    function parseDateValue(dateKey) {
      if (!dateKey || dateKey === 'unknown') {
        return null;
      }
      const value = Date.parse(`${dateKey}T00:00:00Z`);
      return Number.isFinite(value) ? value : null;
    }

    function findLatestDayKey(entries) {
      let latest = null;
      let latestValue = -Infinity;
      entries.forEach((entry) => {
        if (!entry) return;
        const candidate = parseDateValue(entry.date);
        if (candidate !== null && candidate > latestValue) {
          latestValue = candidate;
          latest = entry.date;
        }
      });
      if (latest) {
        return latest;
      }
      return entries[entries.length - 1]?.date ?? 'unknown';
    }

    function updateDailyTable() {
      if (!currentDailyRows.length) {
        dailyBody.innerHTML = '<tr><td colspan="8">No runs recorded for today yet.</td></tr>';
        return;
      }
      dailyBody.innerHTML = currentDailyRows.map(buildDailyRowMarkup).join('');
    }

    function updateDaySummaryTable() {
      daySummaryBody.innerHTML = currentDaySummaryRows
        .map((row) => {
          const anchor = getDayAnchor(row.rawDate);
          const isSelected = row.rawDate === activeDayKey;
          return `<tr data-anchor="${anchor}" data-date="${row.rawDate}" tabindex="0" class="${
            isSelected ? 'selected-day' : ''
          }">
            <td>${row.dateLabel}</td>
            <td class="numeric" data-field="totalRuns">${row.totalRuns}</td>
            <td class="numeric" data-field="totalMinutes">${formatter.format(row.totalMinutes)}</td>
            <td class="numeric" data-field="avgVybes">${formatter.format(row.avgVybes)}</td>
            <td>${row.profilesLabel}</td>
            <td><div class="version-tag-group">${formatVersionTags(row.repoVersions)}</div></td>
          </tr>`;
        })
        .join('');
      attachDaySummaryHandlers();
      highlightSelectedDay();
    }

    function attachDaySummaryHandlers() {
      const rows = Array.from(daySummaryBody.querySelectorAll('tr[data-anchor]'));
      rows.forEach((row) => {
        const target = row.dataset.anchor;
        const triggerScroll = () => scrollToRunDay(target);
        row.addEventListener('click', () => {
          setActiveDay(row.dataset.date);
          triggerScroll();
        });
        row.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            setActiveDay(row.dataset.date);
            triggerScroll();
          }
        });
      });
    }

    function setActiveDay(dateKey) {
      if (!dateKey) return;
      activeDayKey = dateKey;
      highlightSelectedDay();
      renderRunLog();
    }

    function highlightSelectedDay() {
      const rows = Array.from(daySummaryBody.querySelectorAll('tr[data-date]'));
      rows.forEach((row) => {
        if (row.dataset.date === activeDayKey) {
          row.classList.add('selected-day');
        } else {
          row.classList.remove('selected-day');
        }
      });
    }

    function renderDaySummary(entry) {
      if (!entry) {
        return '';
      }
      const rows = createDailyRows([entry]);
      if (!rows.length) {
        return '';
      }
      const label =
        entry.date === 'unknown'
          ? 'Unknown Date'
          : dayFormatter.format(new Date(`${entry.date}T00:00:00Z`));
      return `<div class="run-day-summary">
        <div class="run-day-summary-head">Daily Overview for ${label}</div>
        <div class="table-wrapper compact">
          <table>
            <thead>
              <tr>
                <th>Profile</th>
                <th class="numeric">Total Vybes</th>
                <th class="numeric">Runs</th>
                <th class="numeric">Avg Vybes</th>
                <th class="numeric">Avg Success</th>
                <th class="numeric">Avg Penalty</th>
                <th>Best Run</th>
                <th>Worst Run</th>
              </tr>
            </thead>
            <tbody>
              ${rows.map(buildDailyRowMarkup).join('')}
            </tbody>
          </table>
        </div>
      </div>`;
    }

    function getDayAnchor(rawDate) {
      return `run-day-${rawDate && rawDate !== 'unknown' ? rawDate : 'unknown'}`;
    }

    function scrollToRunDay(anchorId) {
      if (!anchorId) return;
      const section = document.getElementById(anchorId);
      if (!section) return;
      section.scrollIntoView({ behavior: 'smooth', block: 'start' });
      section.classList.add('run-day-highlight');
      setTimeout(() => section.classList.remove('run-day-highlight'), 1200);
    }

    function registerConfig(configId) {
      if (!configId || configSet.has(configId)) {
        return;
      }
      configSet.add(configId);
      configOrder.push(configId);
    }

    function groupRuns(runs, configs) {
      const map = new Map();
      runs.forEach((run) => {
        const key = run.date ?? 'unknown';
        if (!map.has(key)) {
          map.set(key, []);
        }
        map.get(key).push(run);
      });
      return Array.from(map.entries())
        .map(([date, list]) => {
          const evalMap = new Map();
          list.forEach((run) => {
            if (!evalMap.has(run.evalName)) {
              evalMap.set(run.evalName, []);
            }
            evalMap.get(run.evalName).push(run);
          });
          const evalGroups = Array.from(evalMap.entries()).map(([evalName, evalRuns]) => {
            const orderedRuns = configs.map((configId) => evalRuns.find((run) => run.configId === configId)).filter(Boolean);
            return {
              evalName,
              runs: orderedRuns.length ? orderedRuns : evalRuns.sort((a, b) => a.profileLabel.localeCompare(b.profileLabel))
            };
          });
          return {
            date,
            runs: list.sort((a, b) => b.finishedAtValue - a.finishedAtValue),
            evalGroups
          };
        })
        .sort((a, b) => {
          if (a.date === b.date) return 0;
          if (a.date === 'unknown') return 1;
          if (b.date === 'unknown') return -1;
          return a.date > b.date ? -1 : 1;
        });
    }

    function renderRunLog() {
      runLogContainer.innerHTML = currentRunGroups
        .map((group) => {
          const anchorId = getDayAnchor(group.date);
          const firstTimestamp = group.runs[0]?.finishedAtValue ?? null;
          const label =
            group.date === 'unknown'
              ? 'Unknown Date'
              : dayFormatter.format(firstTimestamp ? new Date(firstTimestamp) : new Date(`${group.date}T00:00:00Z`));
          const totalMinutes = group.runs.reduce((sum, run) => sum + (run.actualTimeMinutes ?? 0), 0);
          const profiles = [...new Set(group.runs.map((run) => run.profileLabel))].join(', ');
          const versions = [...new Set(group.runs.map((run) => run.repoVersion).filter(Boolean))];
          const summaryEntry = dailyEntriesByDate.get(group.date);
          const isActiveDay = group.date === activeDayKey;
          const summaryBlock = isActiveDay ? renderDaySummary(summaryEntry) : '';
          const evalTable = buildDayEvalTable(group);
          const evalRunsMarkup = group.evalGroups
            .map(({ evalName, runs }) => renderRunEvalGroup(evalName, runs))
            .join('');
          return `<section class="run-day${isActiveDay ? ' active-day' : ''}" id="${anchorId}">
            <div class="run-day-head">
              <div>
                <h3>${label}</h3>
                <small>${group.runs.length} run${group.runs.length === 1 ? '' : 's'} · ${formatter.format(totalMinutes)} total minutes</small>
              </div>
              <div class="run-day-meta">
                <span>${profiles}</span>
                <div class="version-tag-group">${formatVersionTags(versions)}</div>
              </div>
            </div>
            ${summaryBlock}
            ${evalTable}
            <div class="run-accordion">
              ${evalRunsMarkup || '<p class="badge-fail">No scenario details recorded.</p>'}
            </div>
          </section>`;
        })
        .join('');
    }

    function buildDayEvalTable(group) {
      const configs = orderedConfigs.length ? orderedConfigs : Object.keys(PROFILE_LABELS);
      if (!group.evalGroups.length || !configs.length) {
        return '';
      }
      const headerCells = configs
        .map((configId) => `<th class="numeric">${PROFILE_LABELS[configId] ?? configId}</th>`)
        .join('');
      const rows = group.evalGroups
        .map(({ evalName, runs }) => {
          const label = EVAL_LABELS[evalName] ?? evalName;
          const cells = configs.map((configId) => {
            const run = runs.find((entry) => entry.configId === configId);
            return formatEvalCell(run);
          });
          return `<tr>
            <td>${label}</td>
            ${cells.join('')}
          </tr>`;
        })
        .join('');
      return `<div class="table-wrapper compact eval-breakdown">
        <table class="day-eval-table">
          <thead>
            <tr>
              <th>Scenario</th>
              ${headerCells}
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>
      </div>`;
    }

    function formatEvalCell(run) {
      if (!run) {
        return '<td class="day-eval-cell day-eval-missing">–</td>';
      }
      const score = formatter.format(run.finalScore);
      const success = percentFormatter.format(run.successPercentage);
      const minutes = formatter.format(run.actualTimeMinutes);
      const badgeClass =
        run.finalScore >= 90 ? 'badge-pass' : run.finalScore > 0 ? 'badge-warn' : 'badge-fail';
      return `<td class="day-eval-cell">
        <div class="cell-score ${badgeClass}">${score} vybes</div>
        <div class="cell-meta">${success} · ${minutes} min</div>
      </td>`;
    }

    function renderRunEvalGroup(evalName, runs = []) {
      const scenario = EVAL_LABELS[evalName] ?? evalName;
      if (!runs.length) {
        return '';
      }
      return `<div class="run-eval-group">
        <div class="run-eval-head">${scenario}</div>
        ${runs.map(renderRunCard).join('')}
      </div>`;
    }

    function formatBytes(bytes) {
      if (!bytes || bytes <= 0) return '';
      const units = ['B', 'KB', 'MB', 'GB'];
      let index = 0;
      let value = bytes;
      while (value >= 1024 && index < units.length - 1) {
        value /= 1024;
        index++;
      }
      return `${value.toFixed(1)} ${units[index]}`;
    }

    function renderRunCard(run) {
      const scenario = EVAL_LABELS[run.evalName] ?? run.evalName;
      const finishedLabel = run.finishedAtValue ? dateFormatter.format(new Date(run.finishedAtValue)) : 'unknown';
      const modules = Object.entries(run.vybes.breakdown?.modules ?? {});
      const moduleSummary = modules.length
        ? modules
            .map(([name, stats]) => `<span>${name}: ${stats.passed}/${stats.total}</span>`)
            .join('')
        : '<span>Modules unavailable</span>';
      const sizeLabel = run.workspaceZip?.size ? formatBytes(run.workspaceZip.size) : '';
      const artifactLink = run.workspaceZip?.path
        ? `<a href="${run.workspaceZip.path}" download>workspace.zip${sizeLabel ? ` (${sizeLabel})` : ''}</a>`
        : '';
      const notes = run.error ? `<div class="run-notes badge-fail">${run.error}</div>` : '';
      return `<details class="run-card">
        <summary>
          <div class="run-summary-main">
            <span class="run-profile">${run.profileLabel}</span>
            <span class="run-scenario">${scenario}</span>
          </div>
          <div class="run-summary-meta">
            <span class="run-score">${formatter.format(run.finalScore)} vybes</span>
            <span>${percentFormatter.format(run.successPercentage)}</span>
            <span>${formatter.format(run.actualTimeMinutes)} min</span>
            <span class="version-pill">${run.repoVersion ?? 'unknown'}</span>
          </div>
        </summary>
        <div class="run-details">
          <div class="run-meta">
            <div>
              <strong>Finished</strong>
              <span>${finishedLabel}</span>
            </div>
            <div>
              <strong>Subtasks</strong>
              <span>${run.subtasksPassed}/${run.subtasksTotal}</span>
            </div>
            <div>
              <strong>Penalty</strong>
              <span>${formatter.format(run.timePenaltyMultiplier)}</span>
            </div>
            <div>
              <strong>Success</strong>
              <span>${percentFormatter.format(run.successPercentage)}</span>
            </div>
          </div>
          <div class="run-links">
            ${artifactLink || ''}
            ${run.workspaceArchive ? `<small>${run.workspaceArchive}</small>` : ''}
          </div>
          <div class="run-modules">
            <strong>Modules</strong>
            <div class="module-grid">${moduleSummary}</div>
          </div>
          ${notes}
        </div>
      </details>`;
    }

    function sortRows(rows, sortState, field, numeric = true, forceDesc) {
      const desc = typeof forceDesc === 'boolean' ? forceDesc : sortState.field === field ? !sortState.desc : true;
      sortState.field = field;
      sortState.desc = desc;
      rows.sort((a, b) => {
        const valueA = a[field];
        const valueB = b[field];
        if (numeric) {
          return desc ? (valueB ?? 0) - (valueA ?? 0) : (valueA ?? 0) - (valueB ?? 0);
        }
        const strA = String(valueA ?? '').toLowerCase();
        const strB = String(valueB ?? '').toLowerCase();
        if (strA < strB) return desc ? 1 : -1;
        if (strA > strB) return desc ? -1 : 1;
        return 0;
      });
      return desc;
    }

    function markSortHeader(table, field, desc) {
      const headers = Array.from(table.querySelectorAll('th.sortable'));
      headers.forEach((header) => {
        header.classList.remove('sorted', 'asc', 'desc');
        if (header.dataset.field === field) {
          header.classList.add('sorted', desc ? 'desc' : 'asc');
        }
      });
    }

    function bindSortHandlers(table, rows, sortState, updateFn, fieldConfig) {
      const headers = Array.from(table.querySelectorAll('th.sortable'));
      headers.forEach((header) => {
        header.addEventListener('click', () => {
          const field = header.dataset.field;
          const config = fieldConfig[field] ?? {};
          const numeric = config.numeric ?? true;
          const desc = sortRows(rows, sortState, field, numeric);
          updateFn();
          markSortHeader(table, field, desc);
        });
      });
      markSortHeader(table, sortState.field, sortState.desc);
    }

    async function bootstrap() {
      try {
        const [daily, runs] = await Promise.all([
          safeFetch('vybes-daily.json'),
          safeFetch('vybes-runs.json')
        ]);

        dailyEntriesByDate.clear();
        daily.forEach((entry) => {
          const key = entry.date ?? 'unknown';
          dailyEntriesByDate.set(key, entry);
        });

        latestDayKey = daily.length ? findLatestDayKey(daily) : null;
        activeDayKey = latestDayKey ?? (daily[daily.length - 1]?.date ?? 'unknown');

        const heroEntries = [];
        if (latestDayKey && dailyEntriesByDate.has(latestDayKey)) {
          heroEntries.push(dailyEntriesByDate.get(latestDayKey));
        } else if (daily.length) {
          heroEntries.push(daily[daily.length - 1]);
        }

        currentDailyRows = createDailyRows(heroEntries);
        sortRows(currentDailyRows, dailySort, dailySort.field, true, true);
        updateDailyTable();

        currentDaySummaryRows = createDaySummaryRows(daily);
        sortRows(currentDaySummaryRows, daySort, daySort.field, true, true);
        updateDaySummaryTable();

        currentRunRows = runs.map((run) => {
          const subtasksPassed = run.vybes.breakdown?.subtasksPassed ?? 0;
          const subtasksTotal = run.vybes.breakdown?.subtasksTotal ?? 0;
          registerConfig(run.configId);
          return {
            ...run,
            profileLabel: PROFILE_LABELS[run.configId] ?? run.configId,
            finalScore: run.vybes.finalScore ?? 0,
            successPercentage: run.vybes.successPercentage ?? 0,
            timePenaltyMultiplier: run.vybes.timePenaltyMultiplier ?? 0,
            actualTimeMinutes: run.vybes.actualTimeMinutes ?? 0,
            subtasksPassed,
            subtasksTotal,
            finishedAtValue: run.finishedAt ? Date.parse(run.finishedAt) : 0,
            error: run.vybes.error ?? null,
            repoVersion: run.repoVersion ?? run.vybes.repoVersion ?? 'unknown'
          };
        });
        currentRunRows.sort((a, b) => b.finishedAtValue - a.finishedAtValue);
        orderedConfigs = configOrder.length ? [...configOrder] : [];
        currentRunGroups = groupRuns(currentRunRows, orderedConfigs);
        renderRunLog();

        bindSortHandlers(dailyTable, currentDailyRows, dailySort, updateDailyTable, {
          profileLabel: { numeric: false },
          totalVybes: { numeric: true },
          runs: { numeric: true },
          avgVybes: { numeric: true },
          avgSuccess: { numeric: true },
          avgPenalty: { numeric: true }
        });

        bindSortHandlers(daySummaryTable, currentDaySummaryRows, daySort, updateDaySummaryTable, {
          sortValue: { numeric: true },
          totalRuns: { numeric: true },
          totalMinutes: { numeric: true },
          avgVybes: { numeric: true },
          profilesLabel: { numeric: false },
          versionsLabel: { numeric: false }
        });

        const latest = currentRunRows.find((row) => row.finishedAtValue);
        updatedAtEl.textContent = latest ? dateFormatter.format(new Date(latest.finishedAtValue)) : 'unknown';
      } catch (error) {
        const message = `${error.message}. Serve this directory over HTTP to enable fetch().`;
        dailyBody.innerHTML = `<tr><td colspan="8">${message}</td></tr>`;
        daySummaryBody.innerHTML = `<tr><td colspan="6">${message}</td></tr>`;
        runLogContainer.innerHTML = `<p class="badge-fail">${message}</p>`;
        console.error(error);
      }
    }

    bootstrap();
  </script>
</body>
</html>
